/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package org.jlab.data.func;

import org.jlab.data.graph.DataSet;

/**
 *
 * @author gavalian
 */
public class FunctionFactory {
    
    public static double[] getUniformAxis(int bins, double min, double max){
        double[] axis = new double[bins];
        double width = (max-min)/bins;
        for(int loop = 0; loop < bins; loop++){
            axis[loop] = min + 0.5*width + loop * width;
        }
        return axis;
    }
    
    public static double[] getGaussianValues(double[] axis, double amp,double mean, double sigma){
        double[] values = new double[axis.length];
        for(int loop = 0; loop < values.length; loop++){
            double diff = mean - axis[loop];
            values[loop] = 2.0 + amp*Math.exp(-diff*diff/(2.0*sigma*sigma));
        }
        return values;
    }
    
    public static double[] getGaussianValues(double[] axis, double mean, double sigma){
        return FunctionFactory.getGaussianValues(axis, 1.0, mean, sigma);
    }
    
    
    public static double  gauss(double x, double mean, double sigma){
        return Math.exp(-(x-mean)*(x-mean)/(2.0*sigma*sigma));
    }
    
    public static DataSet getGauss(int bins, double min, double max, double amp, double mean, double sigma){
        DataSet data = new DataSet();
        double width = (max-min)/bins;
        for(int loop = 0; loop < bins; loop++){
            double x = min + 0.5*width + loop * width;
            double gauss = amp*FunctionFactory.gauss(x, mean, sigma);
            data.add(x, gauss);
        }
        return data;
    }
    
    public static double getRandMinMax(double min, double max){
        return min + (max-min)*Math.random();
    }
    
    /**
     * Returns a random number for given data set. The data set has to be a normalized Riemann Sum
     * for this to work. Use at your own risk. But internal usage is always checks for the validity
     * of distribution.
     * @param data data set in Riemann Sum form
     * @return a random number generated by distribution.
     */
    public static double getRandom(DataSet data){
        if(data.getY(data.getSize()-1)-1.0>0.00001){
            System.err.println("[getRandom] *** ERROR *** provided function is not normalized to 1.0");
            return 0;
        }
        double rand = Math.random();
        int bin = data.findBin(rand);
        double min = 0.0;
        double max = 0.0;
        if(bin<0) return 0.0;
        
        if(bin==0){
            min = data.getX(bin);
            max = data.getX(bin+1);
            return FunctionFactory.getRandMinMax(min, max);
        }
        
        if(bin==data.getSize()-1){
            min = data.getX(bin-1);
            max = data.getX(bin);
            return FunctionFactory.getRandMinMax(min, max);
        }
        
        double xmid = data.getX(bin);
        min = xmid - 0.5*(xmid-data.getX(bin-1));
        max = xmid + 0.5*(data.getX(bin+1)-xmid);
        return FunctionFactory.getRandMinMax(min, max);
    }
    
    public static DataSet getRiemannDivisions(DataSet data, int npoints){
        DataSet result = new DataSet();
        DataSet rieman = data.riemannSum();
        rieman.scaleY(1.0/rieman.getY(rieman.getSize()-1));
        int lastBinFound = 0;
        double step      = 1.0/npoints;
        for(int loop = 0; loop < npoints; loop++){
            double y0  = loop * step + step/2.0;           
            int   bin  = rieman.findBin(y0, lastBinFound);

            double xp  = rieman.getX(bin-1);
            double yp  = rieman.getY(bin-1);
            double x   = rieman.getX(bin);
            double y   = rieman.getY(bin);

            double ylen2  = (y-yp)*(y-yp) + (x-xp)*(x-xp);
            double costh  = (y-yp)/Math.sqrt(ylen2);
            double ycoord = data.getY(bin)*(y0)/y;
            double xcoord = x - (y-y0)*Math.tan(Math.acos(costh));
            System.err.println(String.format("%12.5f %12.5f %12.5f",xcoord,ycoord,data.evaluate(xcoord)));
            //System.err.println(String.format(" %5d  y %12.5f  %12.5f  %12.5f x %12.5f %12.5f %12.5f %12.5f %18.10f",
            //bin,y0, yp, y, xp,x, costh, (x-xp),xcoord));
            //System.err.println(" found bin = " + bin + " y0 = " + y0 + " "  + yp + "  " + y + " " + xp + " " + x + " "
            //+ xcoord);
            //System.err.println(
            //        String.format(" found bin = %12.5f %12.5f %4d %4d" , x,rieman.getY(bin),lastBinFound, bin));
            //double y  = data.getY(bin);
            result.add(xcoord, data.evaluate(xcoord));
            lastBinFound = bin;
        }
        return result;
    }
    
}
